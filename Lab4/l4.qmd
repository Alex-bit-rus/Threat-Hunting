---
title: "Основы обработки данных с помощью R и Dplyr"
author: "alexkondrol@yandex.ru"
format: 
  md:
    output-file: README.md
---

## Цель работы

1. Зекрепить практические навыки использования языка программирования R для обработки данных
2. Закрепить знания основных функций обработки данных экосистемы tidyverse языка R
3. Закрепить навыки исследования метаданных DNS трафика

## Исходные данные

1. Операционная система GNU/Linux
2. Интерпретатор языка программирования R
3. Редактор кода `Positron`
4. Метаданные о DNS трафике в внутренней сети Доброй Организации

## Задание

Используя программный пакет `dplyr`, освоить анализ DNS логов с помощью языка программирования R.

## Ход работы

1. Подготовка данных
    1.1. Импортируйте данные DNS – https://storage.yandexcloud.net/dataset.ctfsec/dns.zip
    1.2. Добавьте пропущенные данные о структуре данных (назначении столбцов)
    1.3. Преобразуйте данные в столбцах в нужный формат
    1.4. Просмотрите общую структуру данных с помощью функции glimpse()

2. Анализ
    2.1. Сколько участников информационного обмена в сети Доброй Организации?
    2.2. Какое соотношение участников обмена внутри сети и участников обращений к внешним ресурсам?
    2.3. Найдите топ-10 участников сети, проявляющих наибольшую сетевую активность.
    2.4. Найдите топ-10 доменов, к которым обращаются пользователи сети и соответственное количество обращений
    2.5. Опеределите базовые статистические характеристики (функция summary() ) интервала времени между последовательными обращениями к топ-10 доменам.
    2.6. Часто вредоносное программное обеспечение использует DNS канал в качестве канала управления, периодически отправляя запросы на подконтрольный злоумышленникам DNS сервер. По периодическим запросам на один и тот же домен можно выявить скрытый DNS канал. Есть ли такие IP адреса в исследуемом датасете?
3. Обогащение данных
    3.1. Определите местоположение (страну, город) и организацию-провайдера для топ-10 доменов. Для этого можно использовать сторонние сервисы, например http://ip-api.com (API-эндпоинт – http://ip-api.com/json).

### Шаг 1 - Подготовка данных

Для начала импортируем наш любимый пакет `dplyr`:

```{r}
library(dplyr)
```

Считаем наш лог:
```{r}
dns_data <- read.table(
  "logs/dns.log",
  sep = "\t",
  header = FALSE,
  fill = TRUE,
  quote = "",
  stringsAsFactors = FALSE
)
```
Добавим названия столбцов, согласно стандартной [спецификации](https://docs.zeek.org/en/master/logs/dns.html)  `zeek`:

```{r}
colnames(dns_data) <- c(
  "ts","uid","id.orig_h","id.orig_p","id.resp_h","id.resp_p",
  "proto","trans_id","query","qclass","qclass_name","qtype",
  "qtype_name","rcode","rcode_name","AA","TC","RD","RA","Z",
  "answers","TTLs","rejected"
)[1:ncol(dns_data)]
```

Из [спецификации](https://docs.zeek.org/en/master/logs/dns.html) мы узнаем значение каждого столбца:

1.  ts             – время события (в секундах от эпохи)
2.  uid            – уникальный идентификатор соединения
3.  id.orig_h      – исходный хост (клиент)
4.  id.orig_p      – исходный порт
5.  id.resp_h      – сервер (обычно DNS-сервер)
6.  id.resp_p      – порт сервера
7.  proto          – протокол (udp/tcp)
8.  trans_id       – ID DNS-транзакции
9.  query          – домен или NetBIOS-имя
10. qclass         – числовой код класса (1 — IN)
11. qclass_name    – имя класса (обычно C_INTERNET)
12. qtype          – числовой код типа запроса (32 = NB)
13. qtype_name     – человекопонятное имя (NB, AAAA, A, MX и т. д.)
14. rcode          – код ответа (–, если нет)
15. rcode_name     – имя кода ответа (–, если нет)
16. AA             – authoritative answer (T/F)
17. TC             – truncated (T/F)
18. RD             – recursion desired (T/F)
19. RA             – recursion available (T/F)
20. Z              – зарезервировано
21. answers        – список ответов (или –)
22. TTLs           – список TTL-ов (или –)
23. rejected       – флаг отклонения (T/F)

Преобразуем данные в столбцах в нужный формат:
```{r}
dns_data$ts <- as.POSIXct(as.numeric(dns_data$ts), origin="1970-01-01", tz="UTC")
dns_data$id.orig_p <- as.integer(dns_data$id.orig_p)
dns_data$id.resp_p <- as.integer(dns_data$id.resp_p)
dns_data$AA <- dns_data$AA == "T"
dns_data$TC <- dns_data$TC == "T"
dns_data$RD <- dns_data$RD == "T"
dns_data$RA <- dns_data$RA == "T"
dns_data$rejected <- dns_data$rejected == "T"
```

Посмотрим общую структуру данных:
```{r}
glimpse(dns_data)
```

### Шаг 2 - Анализ

#### Сколько участников информационного обмена в сети Доброй Организации?

Для этого сложим отправителей и получателей в вектор и найдем количество уникальных элементов (участников):
```{r}
participants <- unique(c(dns_data$id.orig_h, dns_data$id.resp_h))
length(participants)
```

#### 5. Какое соотношение участников обмена внутри сети и участников обращений к внешним ресурсам?

Как всем известно ip-адреса можно разделить на серые и белые (публичные), список диапазонов сервых адресов:

- 192.168.0.0/16
- 10.0.0.0/8, 
- 172.16.0.0/12

Так вот, если обращение было к адресу из диапазона серых адресов, то значит от обращался к внутренней сети, если же наоборот, то к внешней.

Не будем изобретать велосипед, а воспользуемся пакетом `ipaddress` с нужным нам функционалом, но для начала подключим его:

```{r}
library(ipaddress)
```

Нам потребуется единственная функция `is_private`, которая позволи понять, является ли адрес внутренним:
```{r}
ip_addresses <- ip_address(dns_data %>% distinct(id.resp_h) %>% pull(id.resp_h))
internal <- sum(is_private(ip_addresses), na.rm = TRUE)
external <- sum(!is_private(ip_addresses), na.rm = TRUE)
internal / (internal + external)
```

#### Найдите топ-10 участников сети, проявляющих наибольшую сетевую активность.

```{r}
top10_participants <- dns_data %>%
  select(id.orig_h, id.resp_h) %>%
  pivot_longer(everything(), names_to = "role", values_to = "ip") %>%
  filter(!is.na(ip), ip != "-") %>%
  count(ip, name = "events") %>%
  arrange(desc(events)) %>%
  slice_head(n = 10)

top10_participants
```
